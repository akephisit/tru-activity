// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
	"github.com/vektah/gqlparser/v2/ast"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/kruakemaths/tru-activity/backend/graph/model"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
	Auth          func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	HasPermission func(ctx context.Context, obj interface{}, next graphql.Resolver, permission string) (res interface{}, err error)
	HasRole       func(ctx context.Context, obj interface{}, next graphql.Resolver, roles []model.UserRole) (res interface{}, err error)
}

type ComplexityRoot struct {
	Activity struct {
		CreatedAt       func(childComplexity int) int
		CreatedBy       func(childComplexity int) int
		Department      func(childComplexity int) int
		Description     func(childComplexity int) int
		EndDate         func(childComplexity int) int
		Faculty         func(childComplexity int) int
		ID              func(childComplexity int) int
		Location        func(childComplexity int) int
		MaxParticipants func(childComplexity int) int
		Participations  func(childComplexity int) int
		Points          func(childComplexity int) int
		RequireApproval func(childComplexity int) int
		StartDate       func(childComplexity int) int
		Status          func(childComplexity int) int
		Title           func(childComplexity int) int
		Type            func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
	}

	AuthPayload struct {
		Token func(childComplexity int) int
		User  func(childComplexity int) int
	}

	Department struct {
		Activities func(childComplexity int) int
		Code       func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		Faculty    func(childComplexity int) int
		ID         func(childComplexity int) int
		IsActive   func(childComplexity int) int
		Name       func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
		Users      func(childComplexity int) int
	}

	Faculty struct {
		Activities   func(childComplexity int) int
		Code         func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		Departments  func(childComplexity int) int
		Description  func(childComplexity int) int
		ID           func(childComplexity int) int
		IsActive     func(childComplexity int) int
		Name         func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		Users        func(childComplexity int) int
	}

	Mutation struct {
		ApproveParticipation func(childComplexity int, participationID string) int
		CreateActivity       func(childComplexity int, input model.CreateActivityInput) int
		CreateDepartment     func(childComplexity int, input model.CreateDepartmentInput) int
		CreateFaculty        func(childComplexity int, input model.CreateFacultyInput) int
		DeleteActivity       func(childComplexity int, id string) int
		DeleteDepartment     func(childComplexity int, id string) int
		DeleteFaculty        func(childComplexity int, id string) int
		JoinActivity         func(childComplexity int, activityID string) int
		LeaveActivity        func(childComplexity int, activityID string) int
		Login                func(childComplexity int, input model.LoginInput) int
		MarkAttendance       func(childComplexity int, participationID string, attended bool) int
		RefreshToken         func(childComplexity int) int
		Register             func(childComplexity int, input model.RegisterInput) int
		RejectParticipation  func(childComplexity int, participationID string) int
		UpdateActivity       func(childComplexity int, id string, input model.UpdateActivityInput) int
		UpdateDepartment     func(childComplexity int, id string, input model.CreateDepartmentInput) int
		UpdateFaculty        func(childComplexity int, id string, input model.CreateFacultyInput) int
	}

	Participation struct {
		Activity     func(childComplexity int) int
		ApprovedAt   func(childComplexity int) int
		AttendedAt   func(childComplexity int) int
		CreatedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		Notes        func(childComplexity int) int
		RegisteredAt func(childComplexity int) int
		Status       func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
		User         func(childComplexity int) int
	}

	Query struct {
		Activities     func(childComplexity int, limit *int, offset *int, facultyID *string, status *model.ActivityStatus) int
		Activity       func(childComplexity int, id string) int
		Department     func(childComplexity int, id string) int
		Departments    func(childComplexity int, facultyID *string) int
		Faculties      func(childComplexity int) int
		Faculty        func(childComplexity int, id string) int
		Me             func(childComplexity int) int
		MyActivities   func(childComplexity int) int
		MyParticipations func(childComplexity int) int
		Participations func(childComplexity int, activityID *string, userID *string) int
		User           func(childComplexity int, id string) int
		Users          func(childComplexity int, limit *int, offset *int) int
	}

	Subscription struct {
		Type      func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		StartDate func(childComplexity int) int
		Status    func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		User      func(childComplexity int) int
	}

	User struct {
		CreatedAt      func(childComplexity int) int
		Department     func(childComplexity int) int
		Email          func(childComplexity int) int
		Faculty        func(childComplexity int) int
		FirstName      func(childComplexity int) int
		ID             func(childComplexity int) int
		IsActive       func(childComplexity int) int
		LastLoginAt    func(childComplexity int) int
		LastName       func(childComplexity int) int
		Participations func(childComplexity int) int
		QrSecret       func(childComplexity int) int
		Role           func(childComplexity int) int
		StudentID      func(childComplexity int) int
		Subscriptions  func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}
}

type MutationResolver interface {
	Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error)
	Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error)
	RefreshToken(ctx context.Context) (*model.AuthPayload, error)
	CreateActivity(ctx context.Context, input model.CreateActivityInput) (*model.Activity, error)
	UpdateActivity(ctx context.Context, id string, input model.UpdateActivityInput) (*model.Activity, error)
	DeleteActivity(ctx context.Context, id string) (bool, error)
	JoinActivity(ctx context.Context, activityID string) (*model.Participation, error)
	LeaveActivity(ctx context.Context, activityID string) (bool, error)
	ApproveParticipation(ctx context.Context, participationID string) (*model.Participation, error)
	RejectParticipation(ctx context.Context, participationID string) (*model.Participation, error)
	MarkAttendance(ctx context.Context, participationID string, attended bool) (*model.Participation, error)
	CreateFaculty(ctx context.Context, input model.CreateFacultyInput) (*model.Faculty, error)
	UpdateFaculty(ctx context.Context, id string, input model.CreateFacultyInput) (*model.Faculty, error)
	DeleteFaculty(ctx context.Context, id string) (bool, error)
	CreateDepartment(ctx context.Context, input model.CreateDepartmentInput) (*model.Department, error)
	UpdateDepartment(ctx context.Context, id string, input model.CreateDepartmentInput) (*model.Department, error)
	DeleteDepartment(ctx context.Context, id string) (bool, error)
}

type QueryResolver interface {
	Me(ctx context.Context) (*model.User, error)
	Users(ctx context.Context, limit *int, offset *int) ([]*model.User, error)
	User(ctx context.Context, id string) (*model.User, error)
	Faculties(ctx context.Context) ([]*model.Faculty, error)
	Faculty(ctx context.Context, id string) (*model.Faculty, error)
	Departments(ctx context.Context, facultyID *string) ([]*model.Department, error)
	Department(ctx context.Context, id string) (*model.Department, error)
	Activities(ctx context.Context, limit *int, offset *int, facultyID *string, status *model.ActivityStatus) ([]*model.Activity, error)
	Activity(ctx context.Context, id string) (*model.Activity, error)
	MyActivities(ctx context.Context) ([]*model.Activity, error)
	Participations(ctx context.Context, activityID *string, userID *string) ([]*model.Participation, error)
	MyParticipations(ctx context.Context) ([]*model.Participation, error)
}

type SubscriptionResolver interface {
	ActivityUpdated(ctx context.Context, activityID *string) (<-chan *model.Activity, error)
	ParticipationUpdated(ctx context.Context, activityID *string) (<-chan *model.Participation, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *graphql.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, fieldName string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + fieldName {
	default:
		return 0, false
	}
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case "query":
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var errs gqlerror.List
			if ec.recover != nil {
				errs = append(errs, ec.recover...)
			}
			if len(errs) > 0 {
				return &graphql.Response{Errors: errs}
			}
			return &graphql.Response{Data: data}
		}

	case "mutation":
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var errs gqlerror.List
			if ec.recover != nil {
				errs = append(errs, ec.recover...)
			}
			if len(errs) > 0 {
				return &graphql.Response{Errors: errs}
			}
			return &graphql.Response{Data: data}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	recover gqlerror.List
}

var parsedSchema = graphql.MustParseSchema(`
directive @auth on FIELD_DEFINITION
directive @hasRole(roles: [UserRole!]!) on FIELD_DEFINITION
directive @hasPermission(permission: String!) on FIELD_DEFINITION

scalar Time

type User {
  id: ID!
  studentID: String!
  email: String!
  firstName: String!
  lastName: String!
  role: UserRole!
  qrSecret: String!
  faculty: Faculty
  department: Department
  isActive: Boolean!
  lastLoginAt: Time
  createdAt: Time!
  updatedAt: Time!
  participations: [Participation!]!
  subscriptions: [Subscription!]!
}

enum UserRole {
  STUDENT
  SUPER_ADMIN
  FACULTY_ADMIN
  REGULAR_ADMIN
}

type Faculty {
  id: ID!
  name: String!
  code: String!
  description: String
  isActive: Boolean!
  createdAt: Time!
  updatedAt: Time!
  departments: [Department!]!
  users: [User!]!
  activities: [Activity!]!
}

type Department {
  id: ID!
  name: String!
  code: String!
  faculty: Faculty!
  isActive: Boolean!
  createdAt: Time!
  updatedAt: Time!
  users: [User!]!
  activities: [Activity!]!
}

type Activity {
  id: ID!
  title: String!
  description: String
  type: ActivityType!
  status: ActivityStatus!
  startDate: Time!
  endDate: Time!
  location: String
  maxParticipants: Int
  requireApproval: Boolean!
  points: Int!
  faculty: Faculty
  department: Department
  createdBy: User!
  createdAt: Time!
  updatedAt: Time!
  participations: [Participation!]!
}

enum ActivityType {
  WORKSHOP
  SEMINAR
  COMPETITION
  VOLUNTEER
  OTHER
}

enum ActivityStatus {
  DRAFT
  ACTIVE
  COMPLETED
  CANCELLED
}

type Participation {
  id: ID!
  user: User!
  activity: Activity!
  status: ParticipationStatus!
  registeredAt: Time!
  approvedAt: Time
  attendedAt: Time
  notes: String
  createdAt: Time!
  updatedAt: Time!
}

enum ParticipationStatus {
  PENDING
  APPROVED
  REJECTED
  ATTENDED
  ABSENT
}

type Subscription {
  id: ID!
  user: User!
  type: SubscriptionType!
  status: SubscriptionStatus!
  startDate: Time!
  endDate: Time!
  createdAt: Time!
  updatedAt: Time!
}

enum SubscriptionType {
  BASIC
  PREMIUM
  VIP
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
}

type AuthPayload {
  token: String!
  user: User!
}

input LoginInput {
  email: String!
  password: String!
}

input RegisterInput {
  studentID: String!
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  facultyID: ID
  departmentID: ID
}

input CreateActivityInput {
  title: String!
  description: String
  type: ActivityType!
  startDate: Time!
  endDate: Time!
  location: String
  maxParticipants: Int
  requireApproval: Boolean!
  points: Int!
  facultyID: ID
  departmentID: ID
}

input UpdateActivityInput {
  title: String
  description: String
  type: ActivityType
  status: ActivityStatus
  startDate: Time
  endDate: Time
  location: String
  maxParticipants: Int
  requireApproval: Boolean
  points: Int
  facultyID: ID
  departmentID: ID
}

input CreateFacultyInput {
  name: String!
  code: String!
  description: String
}

input CreateDepartmentInput {
  name: String!
  code: String!
  facultyID: ID!
}

type Query {
  me: User @auth
  users(limit: Int, offset: Int): [User!]! @hasRole(roles: [SUPER_ADMIN, FACULTY_ADMIN, REGULAR_ADMIN])
  user(id: ID!): User @auth
  
  faculties: [Faculty!]! @auth
  faculty(id: ID!): Faculty @auth
  
  departments(facultyID: ID): [Department!]! @auth
  department(id: ID!): Department @auth
  
  activities(limit: Int, offset: Int, facultyID: ID, status: ActivityStatus): [Activity!]! @auth
  activity(id: ID!): Activity @auth
  myActivities: [Activity!]! @auth
  
  participations(activityID: ID, userID: ID): [Participation!]! @hasRole(roles: [SUPER_ADMIN, FACULTY_ADMIN, REGULAR_ADMIN])
  myParticipations: [Participation!]! @auth
}

type Mutation {
  login(input: LoginInput!): AuthPayload!
  register(input: RegisterInput!): AuthPayload!
  refreshToken: AuthPayload! @auth
  
  createActivity(input: CreateActivityInput!): Activity! @hasRole(roles: [SUPER_ADMIN, FACULTY_ADMIN])
  updateActivity(id: ID!, input: UpdateActivityInput!): Activity! @auth
  deleteActivity(id: ID!): Boolean! @auth
  
  joinActivity(activityID: ID!): Participation! @auth
  leaveActivity(activityID: ID!): Boolean! @auth
  approveParticipation(participationID: ID!): Participation! @hasRole(roles: [SUPER_ADMIN, FACULTY_ADMIN, REGULAR_ADMIN])
  rejectParticipation(participationID: ID!): Participation! @hasRole(roles: [SUPER_ADMIN, FACULTY_ADMIN, REGULAR_ADMIN])
  markAttendance(participationID: ID!, attended: Boolean!): Participation! @hasRole(roles: [SUPER_ADMIN, FACULTY_ADMIN, REGULAR_ADMIN])
  
  createFaculty(input: CreateFacultyInput!): Faculty! @hasRole(roles: [SUPER_ADMIN])
  updateFaculty(id: ID!, input: CreateFacultyInput!): Faculty! @hasRole(roles: [SUPER_ADMIN])
  deleteFaculty(id: ID!): Boolean! @hasRole(roles: [SUPER_ADMIN])
  
  createDepartment(input: CreateDepartmentInput!): Department! @hasRole(roles: [SUPER_ADMIN, FACULTY_ADMIN])
  updateDepartment(id: ID!, input: CreateDepartmentInput!): Department! @hasRole(roles: [SUPER_ADMIN, FACULTY_ADMIN])
  deleteDepartment(id: ID!): Boolean! @hasRole(roles: [SUPER_ADMIN, FACULTY_ADMIN])
}

type Subscription {
  activityUpdated(activityID: ID): Activity!
  participationUpdated(activityID: ID): Participation!
}
`)

// Stub implementations
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	return graphql.Null
}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	return graphql.Null
}