package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/kruakemaths/tru-activity/backend/graph/generated"
	"github.com/kruakemaths/tru-activity/backend/graph/model"
	"github.com/kruakemaths/tru-activity/backend/internal/middleware"
	"github.com/kruakemaths/tru-activity/backend/internal/models"
	"github.com/kruakemaths/tru-activity/backend/pkg/permissions"
	"github.com/kruakemaths/tru-activity/backend/pkg/utils"
)

// ID is the resolver for the id field.
func (r *activityResolver) ID(ctx context.Context, obj *models.Activity) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// ID is the resolver for the id field.
func (r *activityAssignmentResolver) ID(ctx context.Context, obj *models.ActivityAssignment) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// ID is the resolver for the id field.
func (r *activityTemplateResolver) ID(ctx context.Context, obj *models.ActivityTemplate) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// ID is the resolver for the id field.
func (r *departmentResolver) ID(ctx context.Context, obj *models.Department) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// ID is the resolver for the id field.
func (r *facultyResolver) ID(ctx context.Context, obj *models.Faculty) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// ID is the resolver for the id field.
func (r *facultyMetricsResolver) ID(ctx context.Context, obj *models.FacultyMetrics) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	var user models.User
	if err := r.DB.Where("email = ?", input.Email).First(&user).Error; err != nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	if !utils.CheckPasswordHash(input.Password, user.Password) {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Generate JWT token with faculty and department info
	token, err := r.JWTService.GenerateToken(
		user.ID,
		user.Email,
		string(user.Role),
		user.FacultyID,
		user.DepartmentID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}

	// Update last login
	r.DB.Model(&user).Update("last_login_at", "NOW()")

	return &model.AuthPayload{
		Token: token,
		User:  convertUserToGraphQL(&user),
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	// Hash password
	hashedPassword, err := utils.HashPassword(input.Password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password")
	}

	// Generate QR secret
	qrSecret := utils.GenerateQRSecret()

	var facultyID, departmentID *uint
	if input.FacultyID != nil {
		id, _ := strconv.ParseUint(*input.FacultyID, 10, 32)
		facultyIDUint := uint(id)
		facultyID = &facultyIDUint
	}
	if input.DepartmentID != nil {
		id, _ := strconv.ParseUint(*input.DepartmentID, 10, 32)
		departmentIDUint := uint(id)
		departmentID = &departmentIDUint
	}

	user := models.User{
		StudentID:    input.StudentID,
		Email:        input.Email,
		FirstName:    input.FirstName,
		LastName:     input.LastName,
		Password:     hashedPassword,
		Role:         models.UserRoleStudent,
		QRSecret:     qrSecret,
		FacultyID:    facultyID,
		DepartmentID: departmentID,
		IsActive:     true,
	}

	if err := r.DB.Create(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to create user")
	}

	// Generate JWT token
	token, err := r.JWTService.GenerateToken(
		user.ID,
		user.Email,
		string(user.Role),
		user.FacultyID,
		user.DepartmentID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}

	return &model.AuthPayload{
		Token: token,
		User:  convertUserToGraphQL(&user),
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context) (*model.AuthPayload, error) {
	authCtx, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Generate new token
	token, err := r.JWTService.GenerateToken(
		authCtx.User.ID,
		authCtx.User.Email,
		string(authCtx.User.Role),
		authCtx.User.FacultyID,
		authCtx.User.DepartmentID,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to refresh token")
	}

	return &model.AuthPayload{
		Token: token,
		User:  convertUserToGraphQL(authCtx.User),
	}, nil
}

// CreateActivity is the resolver for the createActivity field.
func (r *mutationResolver) CreateActivity(ctx context.Context, input model.CreateActivityInput) (*models.Activity, error) {
	authCtx, err := middleware.RequireRole(ctx, models.UserRoleSuperAdmin, models.UserRoleFacultyAdmin)
	if err != nil {
		return nil, err
	}

	var facultyID, departmentID *uint
	if input.FacultyID != nil {
		id, _ := strconv.ParseUint(*input.FacultyID, 10, 32)
		facultyIDUint := uint(id)
		facultyID = &facultyIDUint

		// Check faculty permission
		if !authCtx.Permissions.HasFacultyPermission(authCtx.User, permissions.PermCreateActivity, facultyIDUint) {
			return nil, fmt.Errorf("permission denied for this faculty")
		}
	}

	if input.DepartmentID != nil {
		id, _ := strconv.ParseUint(*input.DepartmentID, 10, 32)
		departmentIDUint := uint(id)
		departmentID = &departmentIDUint
	}

	var description, location string
	if input.Description != nil {
		description = *input.Description
	}
	if input.Location != nil {
		location = *input.Location
	}

	activity := models.Activity{
		Title:           input.Title,
		Description:     description,
		Type:            models.ActivityType(input.Type),
		Status:          models.ActivityStatusDraft,
		StartDate:       input.StartDate,
		EndDate:         input.EndDate,
		Location:        location,
		MaxParticipants: input.MaxParticipants,
		RequireApproval: input.RequireApproval,
		Points:          input.Points,
		FacultyID:       facultyID,
		DepartmentID:    departmentID,
		CreatedByID:     authCtx.User.ID,
	}

	if err := r.DB.Create(&activity).Error; err != nil {
		return nil, fmt.Errorf("failed to create activity")
	}

	// Load relationships
	r.DB.Preload("Faculty").Preload("Department").Preload("CreatedBy").First(&activity, activity.ID)

	return convertActivityToGraphQL(&activity), nil
}

// UpdateActivity is the resolver for the updateActivity field.
func (r *mutationResolver) UpdateActivity(ctx context.Context, id string, input model.UpdateActivityInput) (*models.Activity, error) {
	panic(fmt.Errorf("not implemented: UpdateActivity - updateActivity"))
}

// DeleteActivity is the resolver for the deleteActivity field.
func (r *mutationResolver) DeleteActivity(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteActivity - deleteActivity"))
}

// JoinActivity is the resolver for the joinActivity field.
func (r *mutationResolver) JoinActivity(ctx context.Context, activityID string) (*models.Participation, error) {
	authCtx, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	actID, err := strconv.ParseUint(activityID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid activity ID")
	}

	// Check if activity exists and is active
	var activity models.Activity
	if err := r.DB.First(&activity, actID).Error; err != nil {
		return nil, fmt.Errorf("activity not found")
	}

	if activity.Status != models.ActivityStatusActive {
		return nil, fmt.Errorf("activity is not active")
	}

	// Check if already participating
	var existingParticipation models.Participation
	if err := r.DB.Where("user_id = ? AND activity_id = ?", authCtx.User.ID, actID).First(&existingParticipation).Error; err == nil {
		return nil, fmt.Errorf("already participating in this activity")
	}

	status := models.ParticipationStatusApproved
	if activity.RequireApproval {
		status = models.ParticipationStatusPending
	}

	participation := models.Participation{
		UserID:     authCtx.User.ID,
		ActivityID: uint(actID),
		Status:     status,
	}

	if err := r.DB.Create(&participation).Error; err != nil {
		return nil, fmt.Errorf("failed to join activity")
	}

	// Load relationships
	r.DB.Preload("User").Preload("Activity").First(&participation, participation.ID)

	return convertParticipationToGraphQL(&participation), nil
}

// LeaveActivity is the resolver for the leaveActivity field.
func (r *mutationResolver) LeaveActivity(ctx context.Context, activityID string) (bool, error) {
	panic(fmt.Errorf("not implemented: LeaveActivity - leaveActivity"))
}

// ApproveParticipation is the resolver for the approveParticipation field.
func (r *mutationResolver) ApproveParticipation(ctx context.Context, participationID string) (*models.Participation, error) {
	panic(fmt.Errorf("not implemented: ApproveParticipation - approveParticipation"))
}

// RejectParticipation is the resolver for the rejectParticipation field.
func (r *mutationResolver) RejectParticipation(ctx context.Context, participationID string) (*models.Participation, error) {
	panic(fmt.Errorf("not implemented: RejectParticipation - rejectParticipation"))
}

// MarkAttendance is the resolver for the markAttendance field.
func (r *mutationResolver) MarkAttendance(ctx context.Context, participationID string, attended bool) (*models.Participation, error) {
	panic(fmt.Errorf("not implemented: MarkAttendance - markAttendance"))
}

// CreateFaculty is the resolver for the createFaculty field.
func (r *mutationResolver) CreateFaculty(ctx context.Context, input model.CreateFacultyInput) (*models.Faculty, error) {
	_, err := middleware.RequireRole(ctx, models.UserRoleSuperAdmin)
	if err != nil {
		return nil, err
	}

	var description string
	if input.Description != nil {
		description = *input.Description
	}

	faculty := models.Faculty{
		Name:        input.Name,
		Code:        input.Code,
		Description: description,
		IsActive:    true,
	}

	if err := r.DB.Create(&faculty).Error; err != nil {
		return nil, fmt.Errorf("failed to create faculty")
	}

	return convertFacultyToGraphQL(&faculty), nil
}

// UpdateFaculty is the resolver for the updateFaculty field.
func (r *mutationResolver) UpdateFaculty(ctx context.Context, id string, input model.CreateFacultyInput) (*models.Faculty, error) {
	panic(fmt.Errorf("not implemented: UpdateFaculty - updateFaculty"))
}

// DeleteFaculty is the resolver for the deleteFaculty field.
func (r *mutationResolver) DeleteFaculty(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteFaculty - deleteFaculty"))
}

// CreateDepartment is the resolver for the createDepartment field.
func (r *mutationResolver) CreateDepartment(ctx context.Context, input model.CreateDepartmentInput) (*models.Department, error) {
	panic(fmt.Errorf("not implemented: CreateDepartment - createDepartment"))
}

// UpdateDepartment is the resolver for the updateDepartment field.
func (r *mutationResolver) UpdateDepartment(ctx context.Context, id string, input model.UpdateDepartmentInput) (*models.Department, error) {
	panic(fmt.Errorf("not implemented: UpdateDepartment - updateDepartment"))
}

// DeleteDepartment is the resolver for the deleteDepartment field.
func (r *mutationResolver) DeleteDepartment(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteDepartment - deleteDepartment"))
}

// CreateSubscription is the resolver for the createSubscription field.
func (r *mutationResolver) CreateSubscription(ctx context.Context, input model.CreateSubscriptionInput) (*model.FacultySubscription, error) {
	_, err := middleware.RequireRole(ctx, models.UserRoleSuperAdmin)
	if err != nil {
		return nil, err
	}

	facultyID, err := strconv.ParseUint(input.FacultyID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid faculty ID")
	}

	subscription := models.Subscription{
		FacultyID: uint(facultyID),
		Type:      models.SubscriptionType(input.Type),
		Status:    models.SubscriptionStatusActive,
		StartDate: input.StartDate,
		EndDate:   input.EndDate,
	}

	if err := r.DB.Create(&subscription).Error; err != nil {
		return nil, fmt.Errorf("failed to create subscription: %v", err)
	}

	r.DB.Preload("Faculty").First(&subscription, subscription.ID)
	return convertSubscriptionToGraphQL(&subscription), nil
}

// UpdateSubscription is the resolver for the updateSubscription field.
func (r *mutationResolver) UpdateSubscription(ctx context.Context, id string, input model.UpdateSubscriptionInput) (*model.FacultySubscription, error) {
	panic(fmt.Errorf("not implemented: UpdateSubscription - updateSubscription"))
}

// DeleteSubscription is the resolver for the deleteSubscription field.
func (r *mutationResolver) DeleteSubscription(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteSubscription - deleteSubscription"))
}

// AssignFacultyAdmin is the resolver for the assignFacultyAdmin field.
func (r *mutationResolver) AssignFacultyAdmin(ctx context.Context, userID string, facultyID string) (*models.User, error) {
	panic(fmt.Errorf("not implemented: AssignFacultyAdmin - assignFacultyAdmin"))
}

// AssignRegularAdmin is the resolver for the assignRegularAdmin field.
func (r *mutationResolver) AssignRegularAdmin(ctx context.Context, userID string, facultyID string, departmentID *string) (*models.User, error) {
	panic(fmt.Errorf("not implemented: AssignRegularAdmin - assignRegularAdmin"))
}

// RemoveAdminRole is the resolver for the removeAdminRole field.
func (r *mutationResolver) RemoveAdminRole(ctx context.Context, userID string) (*models.User, error) {
	panic(fmt.Errorf("not implemented: RemoveAdminRole - removeAdminRole"))
}

// CreateActivityTemplate is the resolver for the createActivityTemplate field.
func (r *mutationResolver) CreateActivityTemplate(ctx context.Context, input model.CreateActivityTemplateInput) (*models.ActivityTemplate, error) {
	panic(fmt.Errorf("not implemented: CreateActivityTemplate - createActivityTemplate"))
}

// UpdateActivityTemplate is the resolver for the updateActivityTemplate field.
func (r *mutationResolver) UpdateActivityTemplate(ctx context.Context, id string, input model.UpdateActivityTemplateInput) (*models.ActivityTemplate, error) {
	panic(fmt.Errorf("not implemented: UpdateActivityTemplate - updateActivityTemplate"))
}

// DeleteActivityTemplate is the resolver for the deleteActivityTemplate field.
func (r *mutationResolver) DeleteActivityTemplate(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteActivityTemplate - deleteActivityTemplate"))
}

// AssignActivity is the resolver for the assignActivity field.
func (r *mutationResolver) AssignActivity(ctx context.Context, input model.CreateActivityAssignmentInput) (*models.ActivityAssignment, error) {
	panic(fmt.Errorf("not implemented: AssignActivity - assignActivity"))
}

// UpdateActivityAssignment is the resolver for the updateActivityAssignment field.
func (r *mutationResolver) UpdateActivityAssignment(ctx context.Context, id string, input model.UpdateActivityAssignmentInput) (*models.ActivityAssignment, error) {
	panic(fmt.Errorf("not implemented: UpdateActivityAssignment - updateActivityAssignment"))
}

// RemoveActivityAssignment is the resolver for the removeActivityAssignment field.
func (r *mutationResolver) RemoveActivityAssignment(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: RemoveActivityAssignment - removeActivityAssignment"))
}

// ScanQRCode is the resolver for the scanQRCode field.
func (r *mutationResolver) ScanQRCode(ctx context.Context, input model.QRScanInput) (*model.QRScanResult, error) {
	panic(fmt.Errorf("not implemented: ScanQRCode - scanQRCode"))
}

// RefreshMyQRSecret is the resolver for the refreshMyQRSecret field.
func (r *mutationResolver) RefreshMyQRSecret(ctx context.Context) (*model.QRData, error) {
	panic(fmt.Errorf("not implemented: RefreshMyQRSecret - refreshMyQRSecret"))
}

// RefreshUserQRSecret is the resolver for the refreshUserQRSecret field.
func (r *mutationResolver) RefreshUserQRSecret(ctx context.Context, userID string) (*model.QRData, error) {
	panic(fmt.Errorf("not implemented: RefreshUserQRSecret - refreshUserQRSecret"))
}

// ID is the resolver for the id field.
func (r *notificationLogResolver) ID(ctx context.Context, obj *models.NotificationLog) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Subscription is the resolver for the subscription field.
func (r *notificationLogResolver) Subscription(ctx context.Context, obj *models.NotificationLog) (*model.FacultySubscription, error) {
	panic(fmt.Errorf("not implemented: Subscription - subscription"))
}

// Type is the resolver for the type field.
func (r *notificationLogResolver) Type(ctx context.Context, obj *models.NotificationLog) (string, error) {
	panic(fmt.Errorf("not implemented: Type - type"))
}

// Status is the resolver for the status field.
func (r *notificationLogResolver) Status(ctx context.Context, obj *models.NotificationLog) (string, error) {
	panic(fmt.Errorf("not implemented: Status - status"))
}

// ID is the resolver for the id field.
func (r *participationResolver) ID(ctx context.Context, obj *models.Participation) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// ID is the resolver for the id field.
func (r *qRScanLogResolver) ID(ctx context.Context, obj *models.QRScanLog) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	authCtx, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}
	return convertUserToGraphQL(authCtx.User), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*models.User, error) {
	_, err := middleware.RequireRole(ctx, models.UserRoleSuperAdmin, models.UserRoleFacultyAdmin, models.UserRoleRegularAdmin)
	if err != nil {
		return nil, err
	}

	query := r.DB.Model(&models.User{}).Preload("Faculty").Preload("Department")

	// Apply faculty filtering for non-super admins
	query = middleware.FilterByFaculty(ctx, query, "faculty_id")

	if offset != nil {
		query = query.Offset(*offset)
	}
	if limit != nil {
		query = query.Limit(*limit)
	}

	var users []models.User
	if err := query.Find(&users).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch users")
	}

	result := make([]*models.User, len(users))
	for i, user := range users {
		result[i] = convertUserToGraphQL(&user)
	}
	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*models.User, error) {
	authCtx, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	var user models.User
	if err := r.DB.Preload("Faculty").Preload("Department").First(&user, userID).Error; err != nil {
		return nil, fmt.Errorf("user not found")
	}

	// Check permission to view user
	if !authCtx.User.CanViewUser(&user) {
		return nil, fmt.Errorf("permission denied")
	}

	return convertUserToGraphQL(&user), nil
}

// Faculties is the resolver for the faculties field.
func (r *queryResolver) Faculties(ctx context.Context) ([]*models.Faculty, error) {
	_, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	var faculties []models.Faculty
	if err := r.DB.Where("is_active = ?", true).Find(&faculties).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch faculties")
	}

	result := make([]*models.Faculty, len(faculties))
	for i, faculty := range faculties {
		result[i] = convertFacultyToGraphQL(&faculty)
	}
	return result, nil
}

// Faculty is the resolver for the faculty field.
func (r *queryResolver) Faculty(ctx context.Context, id string) (*models.Faculty, error) {
	_, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	facultyID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid faculty ID")
	}

	var faculty models.Faculty
	if err := r.DB.First(&faculty, facultyID).Error; err != nil {
		return nil, fmt.Errorf("faculty not found")
	}

	return convertFacultyToGraphQL(&faculty), nil
}

// Departments is the resolver for the departments field.
func (r *queryResolver) Departments(ctx context.Context, facultyID *string) ([]*models.Department, error) {
	panic(fmt.Errorf("not implemented: Departments - departments"))
}

// Department is the resolver for the department field.
func (r *queryResolver) Department(ctx context.Context, id string) (*models.Department, error) {
	panic(fmt.Errorf("not implemented: Department - department"))
}

// Activities is the resolver for the activities field.
func (r *queryResolver) Activities(ctx context.Context, limit *int, offset *int, facultyID *string, status *models.ActivityStatus) ([]*models.Activity, error) {
	_, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	query := r.DB.Model(&models.Activity{}).Preload("Faculty").Preload("Department").Preload("CreatedBy")

	// Apply faculty filtering
	query = middleware.FilterByFaculty(ctx, query, "faculty_id")

	if facultyID != nil {
		fID, _ := strconv.ParseUint(*facultyID, 10, 32)
		query = query.Where("faculty_id = ?", fID)
	}

	if status != nil {
		query = query.Where("status = ?", string(*status))
	}

	if offset != nil {
		query = query.Offset(*offset)
	}
	if limit != nil {
		query = query.Limit(*limit)
	}

	var activities []models.Activity
	if err := query.Find(&activities).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch activities")
	}

	result := make([]*models.Activity, len(activities))
	for i, activity := range activities {
		result[i] = convertActivityToGraphQL(&activity)
	}
	return result, nil
}

// Activity is the resolver for the activity field.
func (r *queryResolver) Activity(ctx context.Context, id string) (*models.Activity, error) {
	panic(fmt.Errorf("not implemented: Activity - activity"))
}

// MyActivities is the resolver for the myActivities field.
func (r *queryResolver) MyActivities(ctx context.Context) ([]*models.Activity, error) {
	panic(fmt.Errorf("not implemented: MyActivities - myActivities"))
}

// Participations is the resolver for the participations field.
func (r *queryResolver) Participations(ctx context.Context, activityID *string, userID *string) ([]*models.Participation, error) {
	panic(fmt.Errorf("not implemented: Participations - participations"))
}

// MyParticipations is the resolver for the myParticipations field.
func (r *queryResolver) MyParticipations(ctx context.Context) ([]*models.Participation, error) {
	panic(fmt.Errorf("not implemented: MyParticipations - myParticipations"))
}

// Subscriptions is the resolver for the subscriptions field.
func (r *queryResolver) Subscriptions(ctx context.Context) ([]*model.FacultySubscription, error) {
	_, err := middleware.RequireRole(ctx, models.UserRoleSuperAdmin)
	if err != nil {
		return nil, err
	}

	var subscriptions []models.Subscription
	if err := r.DB.Preload("Faculty").Find(&subscriptions).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch subscriptions: %v", err)
	}

	result := make([]*model.FacultySubscription, len(subscriptions))
	for i, sub := range subscriptions {
		result[i] = convertSubscriptionToGraphQL(&sub)
	}
	return result, nil
}

// Subscription is the resolver for the subscription field.
func (r *queryResolver) Subscription(ctx context.Context, id string) (*model.FacultySubscription, error) {
	panic(fmt.Errorf("not implemented: Subscription - subscription"))
}

// FacultySubscription is the resolver for the facultySubscription field.
func (r *queryResolver) FacultySubscription(ctx context.Context, facultyID string) (*model.FacultySubscription, error) {
	authCtx, err := middleware.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	fID, err := strconv.ParseUint(facultyID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid faculty ID")
	}

	// Check if user has permission to view this faculty's subscription
	if authCtx.Role != models.UserRoleSuperAdmin && authCtx.FacultyID != nil && *authCtx.FacultyID != uint(fID) {
		return nil, fmt.Errorf("access denied")
	}

	var subscription models.Subscription
	if err := r.DB.Preload("Faculty").Where("faculty_id = ?", fID).First(&subscription).Error; err != nil {
		return nil, fmt.Errorf("subscription not found")
	}

	return convertSubscriptionToGraphQL(&subscription), nil
}

// SystemMetrics is the resolver for the systemMetrics field.
func (r *queryResolver) SystemMetrics(ctx context.Context, fromDate *time.Time, toDate *time.Time) ([]*models.SystemMetrics, error) {
	panic(fmt.Errorf("not implemented: SystemMetrics - systemMetrics"))
}

// FacultyMetrics is the resolver for the facultyMetrics field.
func (r *queryResolver) FacultyMetrics(ctx context.Context, facultyID *string, fromDate *time.Time, toDate *time.Time) ([]*models.FacultyMetrics, error) {
	panic(fmt.Errorf("not implemented: FacultyMetrics - facultyMetrics"))
}

// NotificationLogs is the resolver for the notificationLogs field.
func (r *queryResolver) NotificationLogs(ctx context.Context, subscriptionID *string, limit *int, offset *int) ([]*models.NotificationLog, error) {
	panic(fmt.Errorf("not implemented: NotificationLogs - notificationLogs"))
}

// ActivityTemplates is the resolver for the activityTemplates field.
func (r *queryResolver) ActivityTemplates(ctx context.Context, facultyID *string) ([]*models.ActivityTemplate, error) {
	panic(fmt.Errorf("not implemented: ActivityTemplates - activityTemplates"))
}

// ActivityTemplate is the resolver for the activityTemplate field.
func (r *queryResolver) ActivityTemplate(ctx context.Context, id string) (*models.ActivityTemplate, error) {
	panic(fmt.Errorf("not implemented: ActivityTemplate - activityTemplate"))
}

// ActivityAssignments is the resolver for the activityAssignments field.
func (r *queryResolver) ActivityAssignments(ctx context.Context, activityID *string, adminID *string) ([]*models.ActivityAssignment, error) {
	panic(fmt.Errorf("not implemented: ActivityAssignments - activityAssignments"))
}

// MyActivityAssignments is the resolver for the myActivityAssignments field.
func (r *queryResolver) MyActivityAssignments(ctx context.Context) ([]*models.ActivityAssignment, error) {
	panic(fmt.Errorf("not implemented: MyActivityAssignments - myActivityAssignments"))
}

// MyQRData is the resolver for the myQRData field.
func (r *queryResolver) MyQRData(ctx context.Context) (*model.QRData, error) {
	panic(fmt.Errorf("not implemented: MyQRData - myQRData"))
}

// QRScanLogs is the resolver for the qrScanLogs field.
func (r *queryResolver) QRScanLogs(ctx context.Context, activityID *string, userID *string, limit *int) ([]*models.QRScanLog, error) {
	panic(fmt.Errorf("not implemented: QRScanLogs - qrScanLogs"))
}

// PersonalNotifications is the resolver for the personalNotifications field.
func (r *subscriptionResolver) PersonalNotifications(ctx context.Context, filter *model.SubscriptionFilter) (<-chan *model.SubscriptionPayload, error) {
	panic(fmt.Errorf("not implemented: PersonalNotifications - personalNotifications"))
}

// ActivityUpdates is the resolver for the activityUpdates field.
func (r *subscriptionResolver) ActivityUpdates(ctx context.Context, activityID string) (<-chan *model.SubscriptionPayload, error) {
	panic(fmt.Errorf("not implemented: ActivityUpdates - activityUpdates"))
}

// FacultyUpdates is the resolver for the facultyUpdates field.
func (r *subscriptionResolver) FacultyUpdates(ctx context.Context, facultyID string) (<-chan *model.SubscriptionPayload, error) {
	panic(fmt.Errorf("not implemented: FacultyUpdates - facultyUpdates"))
}

// SystemAlerts is the resolver for the systemAlerts field.
func (r *subscriptionResolver) SystemAlerts(ctx context.Context, filter *model.SubscriptionFilter) (<-chan *model.SubscriptionPayload, error) {
	panic(fmt.Errorf("not implemented: SystemAlerts - systemAlerts"))
}

// QRScanEvents is the resolver for the qrScanEvents field.
func (r *subscriptionResolver) QRScanEvents(ctx context.Context, activityID *string) (<-chan *model.SubscriptionPayload, error) {
	panic(fmt.Errorf("not implemented: QRScanEvents - qrScanEvents"))
}

// ParticipationEvents is the resolver for the participationEvents field.
func (r *subscriptionResolver) ParticipationEvents(ctx context.Context, activityID *string, userID *string) (<-chan *model.SubscriptionPayload, error) {
	panic(fmt.Errorf("not implemented: ParticipationEvents - participationEvents"))
}

// SubscriptionWarnings is the resolver for the subscriptionWarnings field.
func (r *subscriptionResolver) SubscriptionWarnings(ctx context.Context, facultyID *string) (<-chan *model.SubscriptionPayload, error) {
	panic(fmt.Errorf("not implemented: SubscriptionWarnings - subscriptionWarnings"))
}

// ActivityAssignments is the resolver for the activityAssignments field.
func (r *subscriptionResolver) ActivityAssignments(ctx context.Context) (<-chan *model.SubscriptionPayload, error) {
	panic(fmt.Errorf("not implemented: ActivityAssignments - activityAssignments"))
}

// NewActivities is the resolver for the newActivities field.
func (r *subscriptionResolver) NewActivities(ctx context.Context, facultyID *string) (<-chan *model.SubscriptionPayload, error) {
	panic(fmt.Errorf("not implemented: NewActivities - newActivities"))
}

// Heartbeat is the resolver for the heartbeat field.
func (r *subscriptionResolver) Heartbeat(ctx context.Context) (<-chan string, error) {
	panic(fmt.Errorf("not implemented: Heartbeat - heartbeat"))
}

// ID is the resolver for the id field.
func (r *systemAlertResolver) ID(ctx context.Context, obj *models.SystemAlert) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Level is the resolver for the level field.
func (r *systemAlertResolver) Level(ctx context.Context, obj *models.SystemAlert) (string, error) {
	panic(fmt.Errorf("not implemented: Level - level"))
}

// Title is the resolver for the title field.
func (r *systemAlertResolver) Title(ctx context.Context, obj *models.SystemAlert) (string, error) {
	panic(fmt.Errorf("not implemented: Title - title"))
}

// FacultyID is the resolver for the facultyID field.
func (r *systemAlertResolver) FacultyID(ctx context.Context, obj *models.SystemAlert) (*string, error) {
	panic(fmt.Errorf("not implemented: FacultyID - facultyID"))
}

// UserID is the resolver for the userID field.
func (r *systemAlertResolver) UserID(ctx context.Context, obj *models.SystemAlert) (*string, error) {
	panic(fmt.Errorf("not implemented: UserID - userID"))
}

// Data is the resolver for the data field.
func (r *systemAlertResolver) Data(ctx context.Context, obj *models.SystemAlert) (*string, error) {
	panic(fmt.Errorf("not implemented: Data - data"))
}

// Timestamp is the resolver for the timestamp field.
func (r *systemAlertResolver) Timestamp(ctx context.Context, obj *models.SystemAlert) (*time.Time, error) {
	panic(fmt.Errorf("not implemented: Timestamp - timestamp"))
}

// ID is the resolver for the id field.
func (r *systemMetricsResolver) ID(ctx context.Context, obj *models.SystemMetrics) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Subscriptions is the resolver for the subscriptions field.
func (r *userResolver) Subscriptions(ctx context.Context, obj *models.User) ([]*model.FacultySubscription, error) {
	panic(fmt.Errorf("not implemented: Subscriptions - subscriptions"))
}

// Activity returns generated.ActivityResolver implementation.
func (r *Resolver) Activity() generated.ActivityResolver { return &activityResolver{r} }

// ActivityAssignment returns generated.ActivityAssignmentResolver implementation.
func (r *Resolver) ActivityAssignment() generated.ActivityAssignmentResolver {
	return &activityAssignmentResolver{r}
}

// ActivityTemplate returns generated.ActivityTemplateResolver implementation.
func (r *Resolver) ActivityTemplate() generated.ActivityTemplateResolver {
	return &activityTemplateResolver{r}
}

// Department returns generated.DepartmentResolver implementation.
func (r *Resolver) Department() generated.DepartmentResolver { return &departmentResolver{r} }

// Faculty returns generated.FacultyResolver implementation.
func (r *Resolver) Faculty() generated.FacultyResolver { return &facultyResolver{r} }

// FacultyMetrics returns generated.FacultyMetricsResolver implementation.
func (r *Resolver) FacultyMetrics() generated.FacultyMetricsResolver {
	return &facultyMetricsResolver{r}
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// NotificationLog returns generated.NotificationLogResolver implementation.
func (r *Resolver) NotificationLog() generated.NotificationLogResolver {
	return &notificationLogResolver{r}
}

// Participation returns generated.ParticipationResolver implementation.
func (r *Resolver) Participation() generated.ParticipationResolver { return &participationResolver{r} }

// QRScanLog returns generated.QRScanLogResolver implementation.
func (r *Resolver) QRScanLog() generated.QRScanLogResolver { return &qRScanLogResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// SystemAlert returns generated.SystemAlertResolver implementation.
func (r *Resolver) SystemAlert() generated.SystemAlertResolver { return &systemAlertResolver{r} }

// SystemMetrics returns generated.SystemMetricsResolver implementation.
func (r *Resolver) SystemMetrics() generated.SystemMetricsResolver { return &systemMetricsResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type activityResolver struct{ *Resolver }
type activityAssignmentResolver struct{ *Resolver }
type activityTemplateResolver struct{ *Resolver }
type departmentResolver struct{ *Resolver }
type facultyResolver struct{ *Resolver }
type facultyMetricsResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type notificationLogResolver struct{ *Resolver }
type participationResolver struct{ *Resolver }
type qRScanLogResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type systemAlertResolver struct{ *Resolver }
type systemMetricsResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

// Helper converter functions

func convertUserToGraphQL(user *models.User) *models.User {
	return user
}

func convertFacultyToGraphQL(faculty *models.Faculty) *models.Faculty {
	return faculty
}

func convertActivityToGraphQL(activity *models.Activity) *models.Activity {
	return activity
}

func convertParticipationToGraphQL(participation *models.Participation) *models.Participation {
	return participation
}

func convertSubscriptionToGraphQL(subscription *models.Subscription) *model.FacultySubscription {
	return &model.FacultySubscription{
		ID:                strconv.FormatUint(uint64(subscription.ID), 10),
		Faculty:           &subscription.Faculty,
		Type:              subscription.Type,
		Status:            subscription.Status,
		StartDate:         subscription.StartDate,
		EndDate:           subscription.EndDate,
		DaysUntilExpiry:   subscription.DaysUntilExpiry(),
		NeedsNotification: subscription.NeedsNotification(),
		CreatedAt:         subscription.CreatedAt,
		UpdatedAt:         subscription.UpdatedAt,
	}
}

func convertSystemMetricsToGraphQL(metrics *models.SystemMetrics) *models.SystemMetrics {
	return metrics
}

func convertFacultyMetricsToGraphQL(metrics *models.FacultyMetrics) *models.FacultyMetrics {
	return metrics
}
